From 50080e410e97c1acf0b1a750fe4c744cb19b06da Mon Sep 17 00:00:00 2001
From: Leigh Scott <leigh123linux@gmail.com>
Date: Wed, 30 Dec 2020 13:45:09 +0000
Subject: [PATCH 01/11] function: Early-initialize arguments cache or we won't
 ever

---
 gi/function.cpp | 33 ++++++++++++++++++---------------
 1 file changed, 18 insertions(+), 15 deletions(-)

diff --git a/gi/function.cpp b/gi/function.cpp
index f7d71665..ddcfbb0b 100644
--- a/gi/function.cpp
+++ b/gi/function.cpp
@@ -1066,8 +1066,15 @@ uninit_cached_function_data (Function *function)
         // Careful! function->arguments is offset by one or two elements inside
         // the allocated space, so we have to free index -1 or -2.
         int start_index = g_callable_info_is_method(function->info) ? -2 : -1;
-        int gi_argc = g_callable_info_get_n_args(function->info);
-        for (int ix = start_index; ix < gi_argc; ix++) {
+        int gi_argc = MIN(g_callable_info_get_n_args(function->info),
+                          function->js_in_argc + function->js_out_argc);
+
+        for (int i = 0; i < gi_argc; i++) {
+            int ix = start_index + i;
+
+            if (!function->arguments[ix].marshallers)
+                break;
+
             if (function->arguments[ix].marshallers->free)
                 function->arguments[ix].marshallers->free(
                     &function->arguments[ix]);
@@ -1242,6 +1249,11 @@ init_cached_function_data (JSContext      *context,
     GjsArgumentCache* arguments =
         g_new0(GjsArgumentCache, n_args + offset) + offset;
 
+    function->arguments = arguments;
+    function->info = g_base_info_ref(info);
+    function->js_in_argc = 0;
+    function->js_out_argc = 0;
+
     if (is_method &&
         !gjs_arg_cache_build_instance(context, &arguments[-2], info))
         return false;
@@ -1251,8 +1263,7 @@ init_cached_function_data (JSContext      *context,
                                     &inc_counter))
         return false;
 
-    int out_argc = inc_counter ? 1 : 0;
-    int in_argc = 0;
+    function->js_out_argc = inc_counter ? 1 : 0;
 
     for (i = 0; i < n_args; i++) {
         GIDirection direction;
@@ -1271,13 +1282,13 @@ init_cached_function_data (JSContext      *context,
         if (inc_counter) {
             switch (direction) {
                 case GI_DIRECTION_INOUT:
-                    out_argc++;
+                    function->js_out_argc++;
                     [[fallthrough]];
                 case GI_DIRECTION_IN:
-                    in_argc++;
+                    function->js_in_argc++;
                     break;
                 case GI_DIRECTION_OUT:
-                    out_argc++;
+                    function->js_out_argc++;
                     break;
                 default:
                     g_assert_not_reached();
@@ -1285,14 +1296,6 @@ init_cached_function_data (JSContext      *context,
         }
     }
 
-    function->arguments = arguments;
-
-    function->js_in_argc = in_argc;
-    function->js_out_argc = out_argc;
-    function->info = info;
-
-    g_base_info_ref((GIBaseInfo*) function->info);
-
     return true;
 }
 

From 25566639f6e89f0feece104528a30d385c8764bc Mon Sep 17 00:00:00 2001
From: Leigh Scott <leigh123linux@gmail.com>
Date: Wed, 30 Dec 2020 13:48:06 +0000
Subject: [PATCH 02/11] function: Assert the presency of function info only if
 we've arguments

---
 gi/function.cpp | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/gi/function.cpp b/gi/function.cpp
index ddcfbb0b..b98199a4 100644
--- a/gi/function.cpp
+++ b/gi/function.cpp
@@ -1060,9 +1060,10 @@ GJS_NATIVE_CONSTRUCTOR_DEFINE_ABSTRACT(function)
 static void
 uninit_cached_function_data (Function *function)
 {
-    g_assert(function->info && "Don't know how to free cache without GI info");
-
     if (function->arguments) {
+        g_assert(function->info &&
+                 "Don't know how to free cache without GI info");
+
         // Careful! function->arguments is offset by one or two elements inside
         // the allocated space, so we have to free index -1 or -2.
         int start_index = g_callable_info_is_method(function->info) ? -2 : -1;
@@ -1084,8 +1085,7 @@ uninit_cached_function_data (Function *function)
         function->arguments = nullptr;
     }
 
-    g_base_info_unref(function->info);
-
+    g_clear_pointer(&function->info, g_base_info_unref);
     g_function_invoker_destroy(&function->invoker);
 }
 

From 6e3f314f57bf18d3bf8407d47cc9934ffadc0062 Mon Sep 17 00:00:00 2001
From: Leigh Scott <leigh123linux@gmail.com>
Date: Wed, 30 Dec 2020 13:52:54 +0000
Subject: [PATCH 03/11] arg-cache: Throw an error when handling unsupported
 caller-allocates types

---
 gi/arg-cache.cpp | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/gi/arg-cache.cpp b/gi/arg-cache.cpp
index d739a4f1..15e3eb8c 100644
--- a/gi/arg-cache.cpp
+++ b/gi/arg-cache.cpp
@@ -1576,8 +1576,15 @@ bool gjs_arg_cache_build_arg(JSContext* cx, GjsArgumentCache* self,
     *inc_counter_out = true;
 
     GITypeTag type_tag = g_type_info_get_tag(&self->type_info);
-    if (direction == GI_DIRECTION_OUT && type_tag == GI_TYPE_TAG_INTERFACE &&
-        g_arg_info_is_caller_allocates(arg)) {
+    if (direction == GI_DIRECTION_OUT && g_arg_info_is_caller_allocates(arg)) {
+        if (type_tag != GI_TYPE_TAG_INTERFACE) {
+            gjs_throw(cx,
+                      "Unsupported type %s for argument %s with (out "
+                      "caller-allocates)",
+                      g_type_tag_to_string(type_tag), self->arg_name);
+            return false;
+        }
+
         GjsAutoBaseInfo interface_info =
             g_type_info_get_interface(&self->type_info);
         g_assert(interface_info);

From 3d48bb17b91e781170542d3e5ae1b7e9f813e341 Mon Sep 17 00:00:00 2001
From: Leigh Scott <leigh123linux@gmail.com>
Date: Wed, 30 Dec 2020 13:56:24 +0000
Subject: [PATCH 04/11] testGIMarshalling: Introspecting an unsupported
 out-caller allocated throws

---
 installed-tests/js/testGIMarshalling.js | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/installed-tests/js/testGIMarshalling.js b/installed-tests/js/testGIMarshalling.js
index cfd3062f..5c22d9dd 100644
--- a/installed-tests/js/testGIMarshalling.js
+++ b/installed-tests/js/testGIMarshalling.js
@@ -525,6 +525,14 @@ describe('GArray', function () {
             expect(GIMarshallingTests.garray_utf8_full_out_caller_allocated())
                 .toEqual(['0', '1', '2']);
         }).pend('https://gitlab.gnome.org/GNOME/gjs/issues/106');
+
+        // https://gitlab.gnome.org/GNOME/gjs/-/issues/344
+        // the test should be replaced with the one above when issue
+        // https://gitlab.gnome.org/GNOME/gjs/issues/106 is fixed.
+        it('marshals as a transfer-full caller-allocated out parameter throws errors', function () {
+            expect(() => GIMarshallingTests.garray_utf8_full_out_caller_allocated())
+                .toThrowError(/Unsupported type array.*\(out caller-allocates\)/);
+        });
     });
 
     // it('marshals boxed structs as a transfer-full return value', function () {

From 10e9724531b08f69f73f43dcb327fa84809da6f8 Mon Sep 17 00:00:00 2001
From: Leigh Scott <leigh123linux@gmail.com>
Date: Wed, 30 Dec 2020 13:59:21 +0000
Subject: [PATCH 05/11] arg: Fix MIN/MAX safe big integer limits

---
 gi/arg-inl.h       |  4 ++--
 test/gjs-tests.cpp | 32 ++++++++++++++++++++++++++++++++
 2 files changed, 34 insertions(+), 2 deletions(-)

diff --git a/gi/arg-inl.h b/gi/arg-inl.h
index 06330884..d1a36c80 100644
--- a/gi/arg-inl.h
+++ b/gi/arg-inl.h
@@ -167,13 +167,13 @@ inline void gjs_arg_unset(GIArgument* arg) {
 
 template <typename BigT>
 [[nodiscard]] inline constexpr BigT max_safe_big_number() {
-    return BigT(1) << std::numeric_limits<double>::digits;
+    return (BigT(1) << std::numeric_limits<double>::digits) - 1;
 }
 
 template <typename BigT>
 [[nodiscard]] inline constexpr BigT min_safe_big_number() {
     if constexpr (std::is_signed_v<BigT>)
-        return -(max_safe_big_number<BigT>()) + 1;
+        return -(max_safe_big_number<BigT>());
 
     return std::numeric_limits<BigT>::lowest();
 }
diff --git a/test/gjs-tests.cpp b/test/gjs-tests.cpp
index f852c824..b47aa42b 100644
--- a/test/gjs-tests.cpp
+++ b/test/gjs-tests.cpp
@@ -23,6 +23,7 @@
 
 #include <config.h>
 
+#include <stdint.h>
 #include <string.h>  // for size_t, strlen
 
 #include <string>  // for u16string, u32string
@@ -39,7 +40,9 @@
 #include <js/Value.h>
 #include <js/ValueArray.h>
 #include <jsapi.h>
+#include <jspubtd.h>  // for JSProto_Number
 
+#include "gi/arg-inl.h"
 #include "cjs/context.h"
 #include "cjs/error-types.h"
 #include "cjs/jsapi-util.h"
@@ -398,6 +401,30 @@ gjstest_test_profiler_start_stop(void)
         g_message("Temp profiler file not deleted");
 }
 
+static void gjstest_test_safe_integer_max(GjsUnitTestFixture* fx, const void*) {
+    JS::RootedObject number_class_object(fx->cx);
+    JS::RootedValue safe_value(fx->cx);
+
+    g_assert_true(
+        JS_GetClassObject(fx->cx, JSProto_Number, &number_class_object));
+    g_assert_true(JS_GetProperty(fx->cx, number_class_object,
+                                 "MAX_SAFE_INTEGER", &safe_value));
+
+    g_assert_cmpint(safe_value.toNumber(), ==, max_safe_big_number<int64_t>());
+}
+
+static void gjstest_test_safe_integer_min(GjsUnitTestFixture* fx, const void*) {
+    JS::RootedObject number_class_object(fx->cx);
+    JS::RootedValue safe_value(fx->cx);
+
+    g_assert_true(
+        JS_GetClassObject(fx->cx, JSProto_Number, &number_class_object));
+    g_assert_true(JS_GetProperty(fx->cx, number_class_object,
+                                 "MIN_SAFE_INTEGER", &safe_value));
+
+    g_assert_cmpint(safe_value.toNumber(), ==, min_safe_big_number<int64_t>());
+}
+
 int
 main(int    argc,
      char **argv)
@@ -444,6 +471,11 @@ main(int    argc,
     ADD_JSAPI_UTIL_TEST("debug_string/object-with-complicated-to-string",
                         test_jsapi_util_debug_string_object_with_complicated_to_string);
 
+    ADD_JSAPI_UTIL_TEST("gi/args/safe-integer/max",
+                        gjstest_test_safe_integer_max);
+    ADD_JSAPI_UTIL_TEST("gi/args/safe-integer/min",
+                        gjstest_test_safe_integer_min);
+
 #undef ADD_JSAPI_UTIL_TEST
 
     gjs_test_add_tests_for_coverage ();

From 48dd539ed7f41e5a59314417892d12628f9727f6 Mon Sep 17 00:00:00 2001
From: Leigh Scott <leigh123linux@gmail.com>
Date: Wed, 30 Dec 2020 14:01:46 +0000
Subject: [PATCH 06/11] Fix leak when virtual function is unimplemented.

---
 gi/function.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/gi/function.cpp b/gi/function.cpp
index b98199a4..a49fa53b 100644
--- a/gi/function.cpp
+++ b/gi/function.cpp
@@ -1229,6 +1229,7 @@ init_cached_function_data (JSContext      *context,
 
             gjs_throw(context, "Virtual function not implemented: %s",
                       error->message);
+            g_clear_error(&error);
             return false;
         }
 

From d5aa4907961f042dbc09a0d92137f2461df29401 Mon Sep 17 00:00:00 2001
From: Leigh Scott <leigh123linux@gmail.com>
Date: Wed, 30 Dec 2020 14:04:49 +0000
Subject: [PATCH 07/11] console: fix typo in command-line option

---
 cjs/console.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/cjs/console.cpp b/cjs/console.cpp
index 4bbe6e6d..a3220c40 100644
--- a/cjs/console.cpp
+++ b/cjs/console.cpp
@@ -58,7 +58,7 @@ static GOptionEntry entries[] = {
         "Print version of the JS engine and exit" },
     { "command", 'c', 0, G_OPTION_ARG_STRING, &command, "Program passed in as a string", "COMMAND" },
     { "coverage-prefix", 'C', 0, G_OPTION_ARG_STRING_ARRAY, &coverage_prefixes, "Add the prefix PREFIX to the list of files to generate coverage info for", "PREFIX" },
-    { "coverage-output", 0, 0, G_OPTION_ARG_STRING, &coverage_output_path, "Write coverage output to a directory DIR. This option is mandatory when using --coverage-path", "DIR", },
+    { "coverage-output", 0, 0, G_OPTION_ARG_STRING, &coverage_output_path, "Write coverage output to a directory DIR. This option is mandatory when using --coverage-prefix", "DIR", },
     { "include-path", 'I', 0, G_OPTION_ARG_STRING_ARRAY, &include_path, "Add the directory DIR to the list of directories to search for js files.", "DIR" },
     { "profile", 0, G_OPTION_FLAG_OPTIONAL_ARG | G_OPTION_FLAG_FILENAME,
         G_OPTION_ARG_CALLBACK, reinterpret_cast<void *>(&parse_profile_arg),

From 9361405200bd627a6209ccf9b7d8a39f9ab4f377 Mon Sep 17 00:00:00 2001
From: Leigh Scott <leigh123linux@gmail.com>
Date: Wed, 30 Dec 2020 14:07:11 +0000
Subject: [PATCH 08/11] examples: Fix Clutter example

---
 examples/clutter.js | 11 ++++-------
 1 file changed, 4 insertions(+), 7 deletions(-)

diff --git a/examples/clutter.js b/examples/clutter.js
index 4a15669b..a775b60a 100644
--- a/examples/clutter.js
+++ b/examples/clutter.js
@@ -2,7 +2,7 @@ const Clutter = imports.gi.Clutter;
 
 Clutter.init(null);
 
-let stage = new Clutter.Stage();
+const stage = new Clutter.Stage({visible: true});
 
 let texture = new Clutter.Texture({
     filename: 'test.jpg',
@@ -14,12 +14,9 @@ texture.connect('button-press-event', () => {
     return Clutter.EVENT_STOP;
 });
 
-let color = new Clutter.Color();
-color.from_string('Black');
+const [, color] = Clutter.Color.from_string('Black');
+stage.background_color = color;
 
-stage.color = color;
-
-stage.add_actor(texture);
-stage.show();
+stage.add_child(texture);
 
 Clutter.main();

From 4fb55920a79267c1ea2509d1cb2741ff6f807bfe Mon Sep 17 00:00:00 2001
From: Leigh Scott <leigh123linux@gmail.com>
Date: Wed, 30 Dec 2020 14:08:59 +0000
Subject: [PATCH 09/11] Prevent passing null pointers when not nullable.

---
 gi/arg-cache.cpp | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/gi/arg-cache.cpp b/gi/arg-cache.cpp
index 15e3eb8c..c4c1bc41 100644
--- a/gi/arg-cache.cpp
+++ b/gi/arg-cache.cpp
@@ -369,11 +369,10 @@ static bool gjs_marshal_caller_allocates_in(JSContext*, GjsArgumentCache* self,
 }
 
 GJS_JSAPI_RETURN_CONVENTION
-static bool gjs_marshal_null_in_in(JSContext*, GjsArgumentCache*,
+static bool gjs_marshal_null_in_in(JSContext* cx, GjsArgumentCache* self,
                                    GjsFunctionCallState*, GIArgument* arg,
                                    JS::HandleValue) {
-    gjs_arg_unset<void*>(arg);
-    return true;
+    return self->handle_nullable(cx, arg);
 }
 
 GJS_JSAPI_RETURN_CONVENTION

From bd46403a9a947113a6932e094faa705af4e613d6 Mon Sep 17 00:00:00 2001
From: Leigh Scott <leigh123linux@gmail.com>
Date: Wed, 30 Dec 2020 14:11:00 +0000
Subject: [PATCH 10/11] Add test for not-nullable gpointer parameters.

---
 installed-tests/js/testGLib.js | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/installed-tests/js/testGLib.js b/installed-tests/js/testGLib.js
index 1d5bd644..81d0e6fe 100644
--- a/installed-tests/js/testGLib.js
+++ b/installed-tests/js/testGLib.js
@@ -133,6 +133,14 @@ describe('GLib string function overrides', function () {
         numExpectedWarnings = 0;
     });
 
+    // TODO: Add Regress.func_not_nullable_untyped_gpointer_in and move to testRegress.js
+    it('GLib.str_hash errors when marshalling null to a not-nullable parameter', function () {
+        // This tests that we don't marshal null to a not-nullable untyped gpointer.
+        expect(() => GLib.str_hash(null)).toThrowError(
+            /Argument [a-z]+ may not be null/
+        );
+    });
+
     it('GLib.stpcpy', function () {
         expect(() => GLib.stpcpy('dest', 'src')).toThrowError(/not introspectable/);
     });

From c3222c43d680c444df1fe24fe829252518e0649d Mon Sep 17 00:00:00 2001
From: Leigh Scott <leigh123linux@gmail.com>
Date: Wed, 30 Dec 2020 14:13:27 +0000
Subject: [PATCH 11/11] arg-cache: Add fundamental marshaller.

---
 gi/arg-cache.cpp | 78 ++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 76 insertions(+), 2 deletions(-)

diff --git a/gi/arg-cache.cpp b/gi/arg-cache.cpp
index c4c1bc41..cc05fcc8 100644
--- a/gi/arg-cache.cpp
+++ b/gi/arg-cache.cpp
@@ -47,6 +47,7 @@
 #include "gi/boxed.h"
 #include "gi/foreign.h"
 #include "gi/function.h"
+#include "gi/fundamental.h"
 #include "gi/gerror.h"
 #include "gi/gtype.h"
 #include "gi/object.h"
@@ -686,6 +687,35 @@ static bool gjs_marshal_gbytes_in_in(JSContext* cx, GjsArgumentCache* self,
         self->contents.info);
 }
 
+GJS_JSAPI_RETURN_CONVENTION
+static bool gjs_marshal_interface_in_in(JSContext* cx, GjsArgumentCache* self,
+                                        GjsFunctionCallState*, GIArgument* arg,
+                                        JS::HandleValue value) {
+    if (value.isNull())
+        return self->handle_nullable(cx, arg);
+
+    GType gtype = g_registered_type_info_get_g_type(self->contents.info);
+    g_assert(gtype != G_TYPE_NONE);
+
+    if (!value.isObject())
+        return report_gtype_mismatch(cx, self->arg_name, value, gtype);
+
+    JS::RootedObject object(cx, &value.toObject());
+
+    // Could be a GObject interface that's missing a prerequisite,
+    // or could be a fundamental
+    if (ObjectBase::typecheck(cx, object, nullptr, gtype,
+                              GjsTypecheckNoThrow())) {
+        return ObjectBase::transfer_to_gi_argument(
+                        cx, object, arg, GI_DIRECTION_IN, self->transfer, gtype);
+    }
+
+    // If this typecheck fails, then it's neither an object nor a
+    // fundamental
+    return FundamentalBase::transfer_to_gi_argument(
+            cx, object, arg, GI_DIRECTION_IN, self->transfer, gtype);
+}
+
 GJS_JSAPI_RETURN_CONVENTION
 static bool gjs_marshal_object_in_in(JSContext* cx, GjsArgumentCache* self,
                                      GjsFunctionCallState*, GIArgument* arg,
@@ -704,6 +734,25 @@ static bool gjs_marshal_object_in_in(JSContext* cx, GjsArgumentCache* self,
                                                self->transfer, gtype);
 }
 
+GJS_JSAPI_RETURN_CONVENTION
+static bool gjs_marshal_fundamental_in_in(JSContext* cx, GjsArgumentCache* self,
+                                          GjsFunctionCallState*,
+                                          GIArgument* arg,
+                                          JS::HandleValue value) {
+    if (value.isNull())
+        return self->handle_nullable(cx, arg);
+
+    GType gtype = g_registered_type_info_get_g_type(self->contents.info);
+    g_assert(gtype != G_TYPE_NONE);
+
+    if (!value.isObject())
+        return report_gtype_mismatch(cx, self->arg_name, value, gtype);
+
+    JS::RootedObject object(cx, &value.toObject());
+    return FundamentalBase::transfer_to_gi_argument(
+        cx, object, arg, GI_DIRECTION_IN, self->transfer, gtype);
+}
+
 GJS_JSAPI_RETURN_CONVENTION
 static bool gjs_marshal_gtype_struct_instance_in(JSContext* cx,
                                                  GjsArgumentCache* self,
@@ -1091,6 +1140,22 @@ static const GjsArgumentMarshallers object_in_marshallers = {
     gjs_arg_cache_interface_free,  // free
 };
 
+static const GjsArgumentMarshallers interface_in_marshallers = {
+    gjs_marshal_interface_in_in,  // in
+    gjs_marshal_skipped_out,  // out
+    // This is a smart marshaller, no release needed
+    gjs_marshal_skipped_release,  // release
+    gjs_arg_cache_interface_free,  // free
+};
+
+static const GjsArgumentMarshallers fundamental_in_marshallers = {
+    gjs_marshal_fundamental_in_in,  // in
+    gjs_marshal_skipped_out,        // out
+    // This is a smart marshaller, no release needed
+    gjs_marshal_skipped_release,   // release
+    gjs_arg_cache_interface_free,  // free
+};
+
 static const GjsArgumentMarshallers union_in_marshallers = {
     gjs_marshal_union_in_in,  // in
     gjs_marshal_skipped_out,  // out
@@ -1373,8 +1438,7 @@ static bool gjs_arg_cache_build_interface_in_arg(JSContext* cx,
                 return true;
             }
 
-            if (g_type_is_a(gtype, G_TYPE_OBJECT) ||
-                g_type_is_a(gtype, G_TYPE_INTERFACE)) {
+            if (g_type_is_a(gtype, G_TYPE_OBJECT)) {
                 self->marshallers = &object_in_marshallers;
                 return true;
             }
@@ -1396,6 +1460,16 @@ static bool gjs_arg_cache_build_interface_in_arg(JSContext* cx,
                 return true;
             }
 
+            if (G_TYPE_IS_INSTANTIATABLE(gtype)) {
+                self->marshallers = &fundamental_in_marshallers;
+                return true;
+            }
+
+            if (g_type_is_a(gtype, G_TYPE_INTERFACE)) {
+                self->marshallers = &interface_in_marshallers;
+                return true;
+            }
+
             // generic boxed type
             if (gtype == G_TYPE_NONE && self->transfer != GI_TRANSFER_NOTHING) {
                 // Can't transfer ownership of a structure type not
